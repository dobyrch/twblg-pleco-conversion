#!/usr/bin/env python3
import json
import re
import unicodedata
import sys


def main():
    if len(sys.argv) < 2:
        sys.exit('Usage: json_to_txt FILE ...')
    for arg in sys.argv[1:]:
        with open(arg) as f:
            convert_dictionary(json.load(f))


bold_on = '\uEABE'
bold_off = '\uEABF'

link_on = '\uEAB8'
link_off = '\uEABB'

newline  = '\uEAB1'
double_newline = newline + ' ' + newline


def convert_dictionary(dictionary):
    for entry in dictionary:
        headword = entry['title']

        for heteronym in entry['heteronyms']:
            pinyin = '@' + tone_diacritic_to_number(heteronym['trs'])
            definitions = [d for d in heteronym['definitions'] if d['def']]
            split_definition = []

            for i, defdict in enumerate(definitions):
                split_definition.append('')
                definition = defdict['def']

                if definition == '辨\u20DE&nbsp似\u20DE':
                    assert i+2 == len(definitions)
                    split_definition[-1] += bold_on + '辨似' + bold_off + '  '
                    split_definition[-1] += tone_diacritic_to_number(definitions[i+1]['def'])
                    break

                if len(definitions) > 1:
                    split_definition[-1] += bold_on + str(i+1) + bold_off + '  '
                if pos := defdict.get('type'):
                    split_definition[-1] += bold_on + pos + bold_off + '  '

                split_definition[-1] += tone_diacritic_to_number(definition)

                if examples := defdict.get('example'):
                    for i, example in enumerate(examples):
                        example = re.sub('[\uFFF9\uFFFA\uFFFB]', newline, example)
                        split_definition.append(tone_diacritic_to_number(example))

            if synonyms := heteronym.get('synonyms'):
                synonyms = link_on + (link_off + ' ' + link_on).join(synonyms.split(',')) + link_off
                split_definition.append(bold_on + '似' + bold_off + '  '  + synonyms)

            if reading := heteronym.get('reading'):
                split_definition.append('〈' + bold_on + reading + bold_off + '〉')

            definition = double_newline.join(d.strip(newline+' '+'\t'+'\n') for d in split_definition)
            print(headword, pinyin, definition, sep='\t')


tone_map = {
    '\u0301': '2', # acute
    '\u0300': '3', # grave
    '\u0302': '5', # circumflex
    '\u0304': '7', # macron
    '\u030D': '8', # vertical line
    # Some entries include this diacritic;
    # what is it supposed to indicate?
    '\u030B': '6', # double accute
}

d = f"({'|'.join(tone_map)})?"
no_d = ''.join(tone_map)

initial = '(?:b|p|ph|m|t|th|n|j|l|g|k|kh|ng|h|ts|tsh|s)'

final = re.sub('\s+', '', f"""(?:
    a{d}   (?:nn|m|n|ng|p|t|k|h|nnh)? |
    a{d}i  (?:nn|h|nnh)? |
    a{d}u  (?:nn|h|nnh)? |
    e{d}   (?:nn|ng|h|nnh|r)? |
    i{d}   (?:nn|m|n|ng|p|t|k|h|nnh)? |
    ia{d}  (?:nn|m|n|ng|p|t||k|h|nnh)? |
    ia{d}u (?:nn|h)? |
    io{d}  (?:ng|k|h)? |
    iu{d}  (?:nn|n|h|nnh)? |
    o{d}   (?:nn|m|ng|p|k|h|nnh)? |
    o{d}o  (?:h)? |
    u{d}   (?:n|t|h)? |
    ua{d}  (?:nn|n|ng|t|h)? |
    ua{d}i (?:nn|nnh)? |
    ue{d}  (?:h)? |
    u{d}i  (?:nn|h)? |
    n{d}g  (?:h)? |
    m{d}   (?:h)? |

    au{d}  (?:h)? |
    o{d}e  (?:h)? |
    oo{d}  (?:h)? |
    u{d}a  (?:nn|n|t|h)? |
    u{d}e  (?:h)? |
    ui{d}  (?:nn|h)?
)""")

tai_lo = re.compile(f"""
        (?<=[^a-z{no_d}])
        ({initial}?{final})
        (?=[^a-z{no_d}]|$)
    """, re.VERBOSE | re.IGNORECASE)


def tone_diacritic_to_number(string):
    # Add space since look-behind requires fixed-with pattern
    # (i.e. can't match [^a-z]|^)
    string = ' ' +  unicodedata.normalize('NFD', string)
    search_start = 1

    while match := tai_lo.search(string, search_start):
        word = re.sub(d, '', match[0])
        diacritic =  ''.join(match.groups(default='')[1:])
        assert len(diacritic) <= 1

        number = tone_map.get(diacritic)
        if not number:
            if word[-1] in 'ptkh':
                number = '4'
            else:
                number = '1'

        string = string[:match.start()] + word + number + string[match.end():]
        search_start = match.end()

    # Drop the extra space added at the beginning
    return string[1:]


if __name__ == '__main__':
    main()
